## Cold Start 현상

**서버리스 아키텍처에서 특정 함수가 처음 호출되거나 일정 시간 동안 호출되지 않아서 "차가운" 상태에서 시작될 때 발생하는 지연 현상을 나타낸다.**

### 원인:

**새로운 인스턴스의 생성:** 새로운 사용자 요청에 대응하기 위해 새 인스턴스가 프로비저닝되는 경우.
**유휴 상태의 인스턴스 재활용:** 함수가 일정 시간 동안 호출되지 않아 종료되었던 인스턴스가 다시 활성화될 때.

### 결과:
처음 호출 시에 추가적인 초기화 및 설정 작업이 필요하기 때문에 함수의 응답 시간이 길어질 수 있다.

## Lambda Concurrency

**AWS Lambda의 Concurrency는 동시에 실행 중인 또는 실행 대기 중인 함수의 인스턴스 수를 나타낸다. 간단히 말하면, 한 번에 몇 개의 Lambda 함수가 동시에 처리되고 있는지를 나타내는 지표이다.**

### **```Lambda의 기본 동작```**

**Cold Start:** Lambda 함수가 처음 호출되거나 일정 시간 동안 호출되지 않았을 때, 새로운 인스턴스가 시작된다. 이 시작 과정을 'Cold Start'라고 한다.

**Warm Start:** 한 번 실행된 Lambda 함수 인스턴스는 재사용될 수 있다. 이러한 재사용 가능한 인스턴스는 'Warm' 상태로 유지되며, 후속 호출에 대해 빠른 응답 시간을 제공한다.

**동시성 증가:** 요청의 수가 증가하면 Lambda는 자동으로 더 많은 함수 인스턴스를 시작하여 요청을 처리한다. 이렇게 하여 동시 요청을 처리할 수 있는 능력이 확장된다.

**동시성 제한:** AWS 계정은 지역별로 Lambda 함수의 동시 실행 제한이 있다. 이 제한은 기본적으로 1,000이다. 필요에 따라 이 제한을 늘릴 수 있다, 하지만 요청이 이 제한을 초과하면 추가 요청은 대기 상태가 된다.

## Provisioned Concurrency
**AWS Lambda에서 제공하는 기능으로, 람다 함수가 즉시 실행될 수 있도록 지정된 동시 실행 수를 미리 "온 디맨드" 상태로 유지하는 것을 의미한다.**

### **```기본 동작과의 차이점:```**

**```초기 시작 시간```**
**기본 동작:** 함수가 호출될 때 실행 환경이 준비되므로, 새로운 실행 환경에서 시작할 때 초기 시작 지연이 발생할 수 있다.
**Provisioned Concurrency:```** 미리 지정된 수의 실행 환경이 항상 "온 디맨드" 상태로 유지되기 때문에, 초기 시작 지연이 거의 없다.

**```비용```**
**기본 동작:** 호출된 함수의 실행 시간과 메모리 사용량에 따라 비용이 청구된다.
**Provisioned Concurrency:** 프로비전된 동시성 수량 및 실행 시간과 메모리 사용량에 따라 추가 비용이 발생할 수 있다. 항상 "온 디맨드" 상태로 유지하는 것은 비용이 발생한다.

**```예측 가능한 성능```**
**기본 동작:** 트래픽이 증가하면 새로운 실행 환경을 생성하여 처리 능력을 확장해야 하므로 예측하기 어려울 수 있다.
**Provisioned Concurrency:** 미리 설정된 동시성을 통해 예측 가능한 성능과 응답 시간을 제공한다.

## Invocation Model
**서버리스 컴퓨팅 환경에서 함수나 서비스가 호출되는 방식을 나타낸다. AWS Lambda의 경우, 세 가지 주요 호출 모델을 제공한다**

**```동기식 호출:```**
**동작:** 클라이언트는 Lambda 함수를 호출하고, 함수의 실행이 완료될 때까지 기다린다. 함수의 응답은 클라이언트로 반환된다.
```예: API Gateway를 사용하여 웹 요청을 처리할 때.```

**```비동기식 호출:```**
**동작:** 클라이언트는 Lambda 함수를 호출하고 즉시 응답을 받는다. 함수는 백그라운드에서 실행되며, 완료될 때까지 클라이언트가 기다릴 필요가 없다.
```예: S3 버킷에 파일이 업로드되면 이벤트 트리거로 Lambda 함수 호출.```

**```스트림 기반 호출:```**
**동작:** 이벤트 소스로부터 데이터 스트림을 소비하며, Lambda 함수는 배치로 이벤트를 처리한다.
```예: Kinesis 또는 DynamoDB 스트림과 같은 스트림 소스에서 이벤트를 처리할 때.```

### 차이점:

**응답 시간:** 동기식은 호출이 완료될 때까지 기다려야 하므로 응답 시간이 길어질 수 있습니다. 비동기식은 즉시 응답하기 때문에 클라이언트의 대기 시간은 짧습니다.

**클라이언트의 개입:** 동기식은 결과를 기다리는 반면, 비동기식과 스트림 기반은 클라이언트가 함수의 완료를 기다리지 않습니다.

**데이터 처리:** 스트림 기반은 연속적인 데이터 스트림을 처리하므로, 처리 로직이 다소 복잡할 수 있습니다.

## 컨테이너 이미지 기반 함수와 코드 기반 함수의 차이점

**```패키징 및 배포:```**
**코드 기반 함수:** 일반적으로 코드와 해당 의존성을 함께 압축한 ZIP 아카이브 파일을 AWS Lambda에 업로드한다.
**컨테이너 이미지 기반 함수**: Docker 이미지를 빌드하고, 이 이미지를 ECR에 푸시한 후 해당 이미지를 기반으로 Lambda 함수를 생성한다.

**```실행 환경:```**
**코드 기반 함수:** AWS Lambda는 제공된 런타임 환경에서 코드를 직접 실행한다.
컨테이너 이미지 기반 함수: 사용자가 제공한 컨테이너 이미지 내에서 코드가 실행된다. 이를 통해 더 많은 사용자 정의 환경 설정과 라이브러리를 포함할 수 있다.

**```환경 설정 및 의존성 관리:```**
**코드 기반 함수:** requirements.txt나 package.json과 같은 파일을 통해 의존성을 관리한다. 특정 라이브러리나 환경 설정을 사용하려면 추가적인 설정과 함께 람다 레이어를 사용해야 할 수도 있다.
컨테이너 이미지 기반 함수: Dockerfile을 사용하여 필요한 모든 의존성과 환경 설정을 포함하여 커스텀 이미지를 빌드한다.

**```사이즈 제한:```**
**코드 기반 함수:** 패키징된 함수의 최대 사이즈는 50MB (직접 업로드) 또는 250MB (S3를 통한 업로드)로 제한된다.
**컨테이너 이미지 기반 함수:** 이미지의 최대 사이즈는 10GB로 제한된다.